{"id":"chatboti-2p3","title":"Spec: Compare Parquet vs faiss-cpu for vector storage","description":"Evaluate and compare different vector storage options:\n1. Parquet for embeddings storage\n2. faiss-cpu for vector indexing\n3. Performance benchmarks (read/write, query speed)\n4. Storage efficiency and file sizes\n5. Integration complexity\n6. Recommend best approach for this use case","status":"closed","priority":2,"issue_type":"task","owner":"apposite@gmail.com","created_at":"2026-02-12T15:48:13.240105+11:00","created_by":"Bosco Ho","updated_at":"2026-02-12T15:56:40.883262+11:00","closed_at":"2026-02-12T15:56:40.883262+11:00","close_reason":"Completed comparison of vector storage options"}
{"id":"chatboti-68k","title":"Spec: Refactor to generic document storage independent of speaker structure","description":"Design a generic JSON data structure for storing embeddings that is agnostic to the current speaker/agenda domain. The system should work with any document type without hardcoded knowledge of speaker fields (name, bio, abstract, etc.).\n\nGoals:\n1. Define generic document model (id, content, metadata, embeddings)\n2. Separate domain-specific logic from core RAG functionality\n3. Support arbitrary document types and schemas\n4. Maintain backwards compatibility or provide migration path\n5. Consider how this relates to the metadata storage design (chatboti-in9)\n\nDeliverable: Specification document outlining:\n- Current coupling to speaker structure\n- Proposed generic document model\n- API/interface changes needed\n- Migration strategy from current speaker-centric data\n- Integration with metadata storage design","status":"closed","priority":2,"issue_type":"task","owner":"apposite@gmail.com","created_at":"2026-02-12T16:09:56.283331+11:00","created_by":"Bosco Ho","updated_at":"2026-02-12T16:18:34.841118+11:00","closed_at":"2026-02-12T16:18:34.841118+11:00","close_reason":"Completed generic document storage specification"}
{"id":"chatboti-6r7","title":"Refactor: Move embeddings generation to CLI command instead of constructor","description":"Move embedding generation out of the constructor to a separate CLI command. This will:\n1. Improve startup time by not generating embeddings on every initialization\n2. Allow users to explicitly generate/update embeddings when needed\n3. Separate concerns between initialization and embedding computation","status":"closed","priority":2,"issue_type":"task","owner":"apposite@gmail.com","created_at":"2026-02-12T15:47:49.407118+11:00","created_by":"Bosco Ho","updated_at":"2026-02-12T15:55:32.674281+11:00","closed_at":"2026-02-12T15:55:32.674281+11:00","close_reason":"Refactored embeddings generation to separate CLI command"}
{"id":"chatboti-dxz","title":"Spec: Merge embedding storage analysis into generic document storage spec","description":"Integrate the insights from embedding-storage-architecture.md and faiss-vs-numpy-size-comparison.md into docs/generic-document-storage-spec.md.\n\nGoals:\n1. Update Section 3 (Proposed Architecture) to recommend FAISS as primary vector storage\n2. Add Section 2.5 (Storage Format Comparison) with analysis from embedding-storage-architecture.md\n3. Update Section 5 (Integration Points) to include FAISS sizing data\n4. Add performance benchmarks and memory comparisons\n5. Update API examples to show FAISS usage\n6. Keep all existing good content from the original spec\n7. Remove/consolidate redundant sections\n\nKey points to integrate:\n- FAISS is smaller than NumPy (+15 MB vs +300 MB for ChromaDB)\n- FAISS as primary vector storage (not Parquet/SQLite BLOB)\n- Never use List[float] anywhere\n- Always use ndarray[float32]\n- Memory efficiency: 8x better than Python lists\n- Performance: 10-100x faster with FAISS indexing\n- Architecture: FAISS for vectors + SQLite for metadata\n\nDeliverable:\n- Single comprehensive spec: docs/generic-document-storage-spec.md (updated)\n- Archive old analysis docs or delete them after merging","status":"in_progress","priority":1,"issue_type":"task","owner":"apposite@gmail.com","created_at":"2026-02-12T16:46:02.964489+11:00","created_by":"Bosco Ho","updated_at":"2026-02-12T16:46:23.404143+11:00"}
{"id":"chatboti-in9","title":"Spec: Design metadata storage for RAG system","description":"Design metadata storage architecture for RAG pipeline:\n1. Document source tracking (file path, URL, timestamp, etc.)\n2. Embedding index mapping (vector ID to document/chunk)\n3. Chunked text storage (full text vs references)\n4. Return text index for retrieval results\n5. Compare storage approaches (SQLite, JSON, Parquet, separate files)\n6. Query patterns and access efficiency\n7. Recommend optimal metadata storage strategy","status":"closed","priority":2,"issue_type":"task","owner":"apposite@gmail.com","created_at":"2026-02-12T15:48:44.842146+11:00","created_by":"Bosco Ho","updated_at":"2026-02-12T15:56:58.901958+11:00","closed_at":"2026-02-12T15:56:58.901958+11:00","close_reason":"Completed metadata storage design"}
{"id":"chatboti-qlp","title":"Spec: Replace JSON embeddings with faiss-cpu and support multiple documents for RAG","description":"Design and document approach for:\n1. Using faiss-cpu for vector storage instead of JSON serialization\n2. Supporting multiple documents in RAG pipeline\n3. Document indexing, retrieval, and management strategies\n4. Performance and scalability considerations","status":"closed","priority":2,"issue_type":"task","owner":"apposite@gmail.com","created_at":"2026-02-12T15:47:46.48506+11:00","created_by":"Bosco Ho","updated_at":"2026-02-12T16:18:54.396431+11:00","closed_at":"2026-02-12T16:18:54.396431+11:00","close_reason":"Completed comprehensive specification covering FAISS integration, multiple document support, chunking strategies, metadata storage integration, API design, performance targets, and 10-phase implementation roadmap"}
{"id":"chatboti-w6u","title":"Refactor: Convert List[float] to np.ndarray[float32] throughout codebase","description":"Refactor all Python code to use NumPy float32 arrays instead of List[float] for embeddings and vector operations.\n\nGoals:\n1. Find all usages of List[float] in type hints and code\n2. Replace with np.ndarray (dtype=float32)\n3. Update function signatures and type hints\n4. Ensure all embedding operations use NumPy arrays\n5. Update serialization/deserialization to use .npy or binary formats\n6. Maintain backwards compatibility where needed\n\nBenefits:\n- 4-6x memory reduction (see memory-efficiency-analysis.md)\n- 100x faster vector operations with NumPy SIMD\n- Cache-friendly contiguous memory layout\n- Better integration with FAISS (uses float32 internally)\n\nFiles likely affected:\n- chatboti/rag.py (embedding storage and operations)\n- Any utility functions handling embeddings\n- Serialization/deserialization code\n\nTesting:\n- Verify cosine distance calculations produce same results\n- Check memory usage before/after\n- Ensure serialization works correctly","status":"closed","priority":2,"issue_type":"task","owner":"apposite@gmail.com","created_at":"2026-02-12T16:27:29.633278+11:00","created_by":"Bosco Ho","updated_at":"2026-02-12T16:30:26.921265+11:00","closed_at":"2026-02-12T16:30:26.921265+11:00","close_reason":"Completed refactoring to np.ndarray[float32] with full backwards compatibility and testing"}
